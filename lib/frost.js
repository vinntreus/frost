var eventBuilder = require('./event-builder');
var idGeneratorDate = require('./id-generator-date');
var inMemoryStore = require('./in-memory-store');
var _ = require('lodash');

module.exports = function(options){
  options = options || {};
  var store = options.store || inMemoryStore;
  var idGenerator = options.idGenerator || idGeneratorDate;
  var incrementalSnapshot = _.isUndefined(options.incrementalSnapshot) ? true : false;
  var defaultEventData = options.defaultEventData || {};
  var defaultSnapshotKey = options.defaultSnapshotKey;
  var handlers = {};

  if(options.clearStore && store.clear){
    store.clear();
  }

  /*
  * Stores an event in underlying store
  * Events are always cloned to prevent accidental updates
  *
  * params: eventData => { 
  *     name - name of the event
  *     key - master key of the event (is sometimes called AggregateRoot)
  *     id - optional id, else generated by the idGenerator
  *     data - should be your eventdata/payload (but you can store it in any property you wish)  
  *    }
  */
  function storeEvent(eventData){
    eventData = _.extend(eventData, defaultEventData);
    var event = eventBuilder(eventData).withId(idGenerator).validate().build();
    store.addEvent(event);
  }

  /*
  * Retrieve events stored in the master key (or AggregateRoot if you wish)
  * Events are always cloned to avoid accidental updates
  *
  * params : key => event master key
  */
  function getEventsFrom(key){
    return _.map(store.get(key), function(event){
      return _.cloneDeep(event);
    });
  }

  /*
  * Register handler(s), function which is called when publishing an event 
  *
  * params : handler =>  { myHandler : function(){} }
  */
  function registerHandler(handler){
    _.extend(handlers, handler);
  }

  function getHandlers(){
    return _.cloneDeep(handlers);
  }

  function clearHandlers(){
    handlers = {};
  }

  /*
  * Iterates through each stored event and applies corresponding event handler
  * Starts out to create an empty object and passing this through all event handlers
  * Returns build up object
  *
  * params: key => master key of eventstream
  *         snapshot => (optional) object to continue to apply events on.
  *         eventCount => (optional) int, number of events to play starting from the end.
  *                       if not specified (or less than 1), plays all events.
  */
  function playEvents(key, snapshot, eventCount){
    var events = getEventsFrom(key);
    var upTo = events.length;
    var i = 0;

    if(eventCount && eventCount > 0 && eventCount < events.length){
      i = events.length - eventCount;
    }
    
    snapshot = snapshot || {};

    for(; i < upTo; i++){
      if(!handlers[events[i].name]){
        throw 'Missing event handler for "' + events[i].name + '" in "' + key + '"';
      }
      handlers[events[i].name](events[i], snapshot);
    }
    return snapshot;
  }

  function publishEvent(eventData, snapShotKey){
    snapShotKey = snapShotKey || defaultSnapshotKey;
    var snapshot = {};
    var eventCount = null; 
    var nextSnapshot = null;

    if(incrementalSnapshot){
      snapshot = getSnapshot(snapShotKey);
      eventCount = 1;
    } 

    storeEvent(eventData);
    nextSnapshot = playEvents(eventData.key, snapshot, eventCount);
    saveSnapshot(snapShotKey, nextSnapshot);
  }

  function getSnapshot(key){
    return store.get(key);
  }

  function saveSnapshot(key, data){
    store.save(key, data);
  }

  return {
    add : storeEvent,
    clearHandlers : clearHandlers,
    getHandlers : getHandlers,
    getEventsFrom : getEventsFrom,
    getSnapshot : getSnapshot,
    playEvents : playEvents,
    publishEvent : publishEvent,
    registerHandler : registerHandler,
    setIdGenerator : function(generatorFn){ idGenerator = generatorFn; },
    setStore : function(store){ store = store; }
  };
};